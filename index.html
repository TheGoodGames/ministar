<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Story Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.23.0/dist/cytoscape.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-cose-bilkent@4.1.0/cytoscape-cose-bilkent.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a2e;
            color: #e6e6e6;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: calc(100vh - 60px);
            width: 100%;
        }

        #editor {
            width: 40%;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background-color: #16213e;
            border-radius: 10px;
            overflow-y: auto;
            transition: width 0.3s ease;
        }

        #visualization {
            width: 60%;
            min-width: 400px;
            background-color: #232527;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            transition: width 0.3s ease;
        }

        #cy {
            margin: 0;
            padding: 0;
            border: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        textarea,
        input,
        select {
            background-color: #0d1b2a;
            color: #e6e6e6;
            border: 1px solid #415a77;
            border-radius: 5px;
            padding: 10px;
            font-family: inherit;
            box-sizing: border-box;
        }

        textarea {
            height: 120px;
            resize: vertical;
            width: 100%;
        }

        #node-text,
        #node-tag {
            width: 100%;
            box-sizing: border-box;
            font-size: 14px;
            line-height: 1.5;
        }

        button {
            background-color: #415a77;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            min-width: 120px;
        }

        button:hover {
            background-color: #1b263b;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .node-details {
            display: none;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            max-height: 600px;
            padding-right: 5px;
        }

        .choice-item {
            background-color: #1b263b;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .add-choice {
            background-color: #0d845e;
        }

        .save-btn {
            background-color: #3a86ff;
        }

        .export-btn {
            background-color: #8338ec;
        }

        .import-btn {
            background-color: #ff9e6d;
        }

        .reset-layout-btn {
            background-color: #a4161a;
        }

        .save-state-btn {
            background-color: #0d845e;
        }

        .load-state-btn {
            background-color: #4ade80;
        }

        .add-node-btn {
            background-color: #0d845e;
            width: 100%;
            margin-top: 10px;
        }

        .delete-node-btn {
            background-color: #e63946;
            width: 100%;
            margin-top: 15px;
        }

        #node-id {
            font-weight: bold;
            color: #ff9e6d;
        }

        .choice-controls {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .delete-choice {
            background-color: #e63946;
            padding: 3px 8px;
            font-size: 0.8em;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            padding: 10px;
            background-color: #0d1b2a;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #file-input {
            display: none;
        }

        #state-file-input {
            display: none;
        }

        .file-label {
            background-color: #ff9e6d;
            color: #0d1b2a;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-label:hover {
            background-color: #ff8c42;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }

        .success {
            background-color: #0d845e;
            color: white;
        }

        .error {
            background-color: #e63946;
            color: white;
        }

        #resizer {
            width: 10px;
            background-color: #415a77;
            cursor: col-resize;
            height: 100%;
            z-index: 100;
            position: relative;
        }

        #node-selector select {
            width: 100%;
            box-sizing: border-box;
            font-size: 14px;
            padding: 10px;
        }

        .highlighted-edge {
            line-color: #4ade80;
            target-arrow-color: #4ade80;
            width: 5;
        }

        .editor-status {
            font-size: 0.8em;
            color: #a0aec0;
            margin-top: 5px;
        }

        #auto-save {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .storage-info {
            font-size: 0.8em;
            color: #a0aec0;
            margin-top: 5px;
            padding: 5px;
            border-radius: 3px;
            background-color: #0d1b2a;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .loading-text {
            color: white;
            font-size: 24px;
            background-color: #16213e;
            padding: 20px;
            border-radius: 10px;
        }

        /* –ù–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ */
        .color-picker-container {
            margin: 15px 0;
            padding: 12px;
            background-color: #0d1b2a;
            border-radius: 8px;
        }

        .color-preview {
            display: inline-block;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            margin-left: 10px;
            border: 1px solid #415a77;
            vertical-align: middle;
        }

        .branch-type-container {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #415a77;
        }

        .branch-type-tag {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        .node-tooltip {
            position: fixed;
            background-color: #f8f9fa;
            color: #000;
            padding: 12px;
            border-radius: 6px;
            max-width: 600px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 9999;
            display: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 18px;
            line-height: 1.5;
            pointer-events: none;
            border: 1px solid #e9ecef;
            white-space: pre-wrap;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-text {
            display: block;
            margin-top: 0.25rem;
            font-size: 0.875em;
            color: #a0aec0;
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–µ–≥–æ–≤ */
        .tag-label {
            position: absolute;
            background-color: white;
            color: black;
            border-radius: 12px;
            padding: 6px 12px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 999;
            pointer-events: none;
            min-width: 60px;
            white-space: normal;
            text-align: center;
            line-height: 1.2;
            transition: font-size 0.2s ease;
            --tag-width: 100px;
            --tag-height: 30px;
        }

        .tag-label::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 8px solid white;
            z-index: -1;
        }

        .missing-msg-item {
            background: #0d1b2a;
            padding: 6px;
            margin-top: 6px;
            border-radius: 4px;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .missing-msg-item input {
            flex: 1;
            font-size: 13px;
        }

        .delete-missing-msg {
            background: #e63946;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* === –ù–û–í–´–ï –°–¢–ò–õ–ò –î–õ–Ø –õ–û–ö–ê–¶–ò–ô === */
        .location-icon-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
            padding: 6px;
            background: #0d1b2a;
            border-radius: 5px;
        }

        .location-icon-item {
            font-size: 20px;
            text-align: center;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .location-icon-item:hover {
            background: #1b263b;
        }

        .location-icon-item.selected {
            background: #4ade80;
        }
    </style>
</head>

<body>
    <h1>Interactive Story Editor</h1>
    <div class="toolbar">
        <button class="import-btn" id="import-btn">–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JSON</button>
        <input type="file" id="file-input" accept=".json,application/json">
        <button class="save-state-btn" id="save-state-btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ</button>
        <button class="load-state-btn" id="load-state-btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ</button>
        <input type="file" id="state-file-input" accept=".storystate,application/json">
        <button class="export-btn" id="export-json">–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JSON</button>
        <button class="reset-layout-btn" id="reset-layout">–°–±—Ä–æ—Å–∏—Ç—å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ</button>
        <div id="auto-save">
            <input type="checkbox" id="auto-save-checkbox" checked>
            <label for="auto-save-checkbox">–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</label>
        </div>
        <input type="text" id="search-node" placeholder="–ü–æ–∏—Å–∫ —É–∑–ª–∞...">
        <button id="search-btn">–ù–∞–π—Ç–∏</button>
        <div class="status-message" id="status-message"></div>
        <div class="editor-status" id="editor-status">–°–æ—Å—Ç–æ—è–Ω–∏–µ: –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ</div>
        <div class="storage-info" id="storage-info">–î–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ</div>
    </div>
    <div id="container">
        <div id="editor">
            <div id="node-selector">
                <h3>–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:</h3>
                <select id="node-list" size="20"
                    style="width: 100%; padding: 10px; background-color: #0d1b2a; color: white; border: 1px solid #415a77; border-radius: 5px; box-sizing: border-box;">
                </select>
                <button class="add-node-btn" id="add-new-node">–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —É–∑–µ–ª</button>
            </div>
            <div class="node-details" id="node-details">
                <h3>–£–∑–µ–ª: <span id="node-id"></span></h3>
                <div>
                    <label for="node-text">–¢–µ–∫—Å—Ç —É–∑–ª–∞:</label>
                    <textarea id="node-text" rows="8"></textarea>
                </div>

                <!-- === –ù–û–í–´–ô –ë–õ–û–ö: –õ–û–ö–ê–¶–ò–Ø === -->
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="node-is-location-checkbox">
                        –≠—Ç–æ –ª–æ–∫–∞—Ü–∏—è
                    </label>
                    <div id="location-fields"
                        style="display: none; margin-top: 15px; padding: 12px; background: #0d1b2a; border-radius: 5px;">
                        <div><label>–ù–∞–∑–≤–∞–Ω–∏–µ –ª–æ–∫–∞—Ü–∏–∏:</label> <input type="text" id="location_name"
                                placeholder="–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ø–ª–æ—â–∞–¥—å" style="width: 100%;"></div>
                        <div><label>–ö–∞—Ç–µ–≥–æ—Ä–∏—è (–∫–ª—é—á):</label> <input type="text" id="location_category"
                                placeholder="town" style="width: 100%;"></div>
                        <div><label>–û—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:</label> <input type="text" id="category_name"
                                placeholder="üè∞ –ì–æ—Ä–æ–¥–∞ –∏ –ø–æ—Å–µ–ª–µ–Ω–∏—è" style="width: 100%;"></div>
                        <div><label>–û–ø–∏—Å–∞–Ω–∏–µ –ª–æ–∫–∞—Ü–∏–∏:</label> <textarea id="location_description" rows="2"
                                placeholder="–°–µ—Ä–¥—Ü–µ —Å—Ç–∞–Ω—Ü–∏–∏ –õ–µ–≤—Å–∫–∏" style="width: 100%;"></textarea></div>
                        <div><label>–ò–∫–æ–Ω–∫–∞:</label>
                            <div class="location-icon-grid" id="location-icon-grid">
                                <!-- –ò–∫–æ–Ω–∫–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                            </div>
                            <input type="hidden" id="location_icon" value="üèõÔ∏è">
                        </div>
                    </div>
                </div>

                <!-- NPC -->
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="node-is-npc-checkbox">
                        NPC
                    </label>
                </div>

                <!-- –ü–ê–†–û–õ–¨ –ù–ê –£–ó–ï–õ -->
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="node-password-checkbox">
                        –ü–æ—Å—Ç–∞–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å –Ω–∞ —É–∑–µ–ª
                    </label>
                    <div id="password-fields"
                        style="display: none; margin-top: 15px; padding: 12px; background: #0d1b2a; border-radius: 5px;">
                        <div><label>–ó–∞–≥–æ–ª–æ–≤–æ–∫:</label> <input type="text" id="code_title" placeholder="–ö–æ–¥ –¥–æ—Å—Ç—É–ø–∞"
                                style="width: 100%;"></div>
                        <div><label>–ü–æ–¥—Å–∫–∞–∑–∫–∞:</label> <input type="text" id="code_hint"
                                placeholder="–ì–æ–¥ –æ—Å–Ω–æ–≤–∞–Ω–∏—è –∞–∫–∞–¥–µ–º–∏–∏" style="width: 100%;"></div>
                        <div><label>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–æ–¥:</label> <input type="text" id="correct_code" placeholder="1872"
                                style="width: 100%;"></div>
                        <div><label><input type="checkbox" id="case_sensitive"> –£—á–∏—Ç—ã–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä</label></div>
                        <div><label>–°–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ:</label> <input type="text" id="error_message"
                                placeholder="–ë–∏–ø! –ù–µ–≤–µ—Ä–Ω–æ." style="width: 100%;"></div>
                        <div><label>–°–ª–µ–¥—É—é—â–∞—è –≤–µ—Ç–∫–∞ (—É—Å–ø–µ—Ö):</label> <input type="text" id="success_next"
                                placeholder="lab_success" style="width: 100%;"></div>
                    </div>
                </div>

                <!-- –ù–û–í–´–ô –ë–õ–û–ö –í–´–ë–û–†–ê –¶–í–ï–¢–ê -->
                <div class="color-picker-container">
                    <h4>–¶–≤–µ—Ç —É–∑–ª–∞:</h4>
                    <div style="display: flex; align-items: center; margin-top: 8px; gap: 10px;">
                        <input type="color" id="node-color" value="#4cc9f0" style="width: 50px; height: 30px;">
                        <input type="text" id="node-color-hex" value="#4cc9f0" maxlength="7"
                            style="width: 80px; padding: 4px; font-family: monospace; text-align: center;"
                            placeholder="#4cc9f0">
                        <span class="color-preview" id="color-preview" style="width: 28px; height: 28px;"></span>
                        <span style="font-size: 14px;">–í—ã–±—Ä–∞—Ç—å –∏–ª–∏ –≤–≤–µ—Å—Ç–∏ —Ü–≤–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, #ff0000)</span>
                    </div>
                    <div class="branch-type-container">
                        <p style="margin: 5px 0; font-size: 13px; color: #a0aec0;">–ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞:</p>
                        <div style="display: flex; gap: 15px; margin-top: 8px;">
                            <div style="display: flex; align-items: center; cursor: pointer;"
                                onclick="setNodeColor('#ff9e6d')">
                                <span class="branch-type-tag" style="background-color: #ff9e6d;"></span>
                                <span>–ì–ª–∞–≤–Ω–∞—è</span>
                            </div>
                            <div style="display: flex; align-items: center; cursor: pointer;"
                                onclick="setNodeColor('#7209b7')">
                                <span class="branch-type-tag" style="background-color: #7209b7;"></span>
                                <span>–ü–æ–±–æ—á–Ω–∞—è</span>
                            </div>
                            <div style="display: flex; align-items: center; cursor: pointer;"
                                onclick="setNodeColor('#4ade80')">
                                <span class="branch-type-tag" style="background-color: #4ade80;"></span>
                                <span>–°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- –ü–û–õ–ï –î–õ–Ø –¢–ï–ì–ê -->
                <div class="form-group" style="margin-top: 15px;">
                    <label for="node-tag">–¢–µ–≥ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞:</label>
                    <input type="text" id="node-tag" class="form-control" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ì–ª–∞–≤–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è">
                    <small class="form-text text-muted">
                        –≠—Ç–æ—Ç —Ç–µ–≥ –±—É–¥–µ—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤–º–µ—Å—Ç–µ —Å —É–∑–ª–æ–º
                    </small>
                </div>

                <div id="choices-container">
                    <h4>–í–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–±–æ—Ä–∞:</h4>
                </div>
                <div class="controls">
                    <button class="add-choice" id="add-choice">–î–æ–±–∞–≤–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç</button>
                    <button class="save-btn" id="save-node">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —É–∑–µ–ª</button>
                </div>
                <button class="delete-node-btn" id="delete-node">–£–¥–∞–ª–∏—Ç—å —É–∑–µ–ª</button>
            </div>
        </div>
        <div id="resizer"></div>
        <div id="visualization">
            <div id="cy"></div>
            <div id="item-icons-container"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1001;">
            </div>
            <div id="tag-container"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000;">
            </div>
        </div>
    </div>
    <div id="loading-overlay">
        <div class="loading-text">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞...</div>
    </div>
    <div class="node-tooltip" id="node-tooltip"></div>

    <script>
        // === –ö–û–ü–ò–Ø –í–°–ï–ì–û –°–¢–ê–†–û–ì–û JS + –î–û–ë–ê–í–õ–ï–ù–ò–Ø –î–õ–Ø –õ–û–ö–ê–¶–ò–ô ===

        const DB_NAME = 'StoryEditorDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'editorStates';
        let storyData = {};
        let editorState = {
            lastSelectedNode: null,
            nodePositions: {},
            editorWidth: 40,
            visualizationWidth: 60,
            lastSaved: null,
            autoSave: true
        };
        let cy = null;
        let isResizing = false;
        let editorMinWidth = 300;
        let visualizationMinWidth = 400;
        let hasUnsavedChanges = false;
        let db = null;
        let isInitialized = false;
        let historyStack = [];
        let redoStack = [];
        const MAX_HISTORY = 50;
        const ACTION_TYPES = {
            NODE_EDIT: 'NODE_EDIT',
            NODE_DELETE: 'NODE_DELETE',
            NODE_ADD: 'NODE_ADD',
            NODE_MOVE: 'NODE_MOVE',
            LAYOUT_RESET: 'LAYOUT_RESET',
            CHOICE_EDIT: 'CHOICE_EDIT',
            FULL_DATA_REPLACE: 'FULL_DATA_REPLACE'
        };

        // ==== –í–°–¢–ê–í–ö–ê –ù–û–í–û–ì–û –ú–ê–°–°–ò–í–ê –ò–ö–û–ù–û–ö ====
        const LOCATION_ICONS = [
            "üèõÔ∏è", "üè™", "üèØ", "üè∞", "üèïÔ∏è", "üèúÔ∏è", "üåã", "‚õ∞Ô∏è", "üåå", "üåä",
            "üõ∞Ô∏è", "üöÄ", "üîß", "üî¨", "üß™", "üíä", "‚öïÔ∏è", "üìö", "üé≠", "üé™",
            "üé°", "‚õ©Ô∏è", "‚õ™", "üïç", "üïå", "‚õ≤", "üõ§Ô∏è", "üõ∏", "üì°", "‚õ©Ô∏è"
        ];

        function initLocationIcons() {
            const grid = document.getElementById('location-icon-grid');
            grid.innerHTML = '';
            LOCATION_ICONS.forEach(icon => {
                const div = document.createElement('div');
                div.className = 'location-icon-item';
                div.textContent = icon;
                div.addEventListener('click', () => {
                    document.querySelectorAll('.location-icon-item').forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    document.getElementById('location_icon').value = icon;
                    setUnsavedChanges(true);
                });
                grid.appendChild(div);
            });
        }

        // === –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô (showLoading, hideLoading –∏ —Ç.–¥.) ===
        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        function showStatus(message, type) {
            const statusElement = document.getElementById('status-message');
            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;
            statusElement.style.display = 'block';
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000);
        }
        function updateStatus() {
            const statusElement = document.getElementById('editor-status');
            const storageElement = document.getElementById('storage-info');
            if (hasUnsavedChanges) {
                statusElement.textContent = "–°–æ—Å—Ç–æ—è–Ω–∏–µ: –µ—Å—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è";
                statusElement.style.color = "#ff6b6b";
            } else {
                if (editorState.lastSaved) {
                    const lastSavedTime = new Date(editorState.lastSaved).toLocaleTimeString();
                    statusElement.textContent = `–°–æ—Å—Ç–æ—è–Ω–∏–µ: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ ${lastSavedTime}`;
                } else {
                    statusElement.textContent = "–°–æ—Å—Ç–æ—è–Ω–∏–µ: –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ";
                }
                statusElement.style.color = "#4ade80";
            }
            if (db) {
                storageElement.textContent = "–î–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ (IndexedDB)";
                storageElement.style.color = "#4ade80";
            } else {
                storageElement.textContent = "IndexedDB –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è –≤ localStorage.";
                storageElement.style.color = "#ffb703";
            }
        }
        function setUnsavedChanges(value) {
            hasUnsavedChanges = value;
            updateStatus();
        }
        function setNodeColor(color) {
            const picker = document.getElementById('node-color');
            const hex = document.getElementById('node-color-hex');
            const preview = document.getElementById('color-preview');
            if (picker) picker.value = color;
            if (hex) hex.value = color;
            if (preview) preview.style.backgroundColor = color;
            setUnsavedChanges(true);
        }
        function addMissingMessageField(container, keyId = '', message = '') {
            const div = document.createElement('div');
            div.className = 'missing-msg-item';
            div.innerHTML = `
<input type="text" placeholder="ID –∫–ª—é—á–∞" value="${keyId}" class="missing-key-id">
<input type="text" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫—É" value="${message}" class="missing-key-msg">
<button type="button" class="delete-missing-msg">√ó</button>
`;
            container.appendChild(div);
            div.querySelector('.delete-missing-msg').addEventListener('click', () => div.remove());
        }
        function saveToHistory(actionType, description, dataBefore = null, dataAfter = null, nodeId = null) {
            const stateSnapshot = {
                storyData: JSON.parse(JSON.stringify(storyData)),
                nodePositions: JSON.parse(JSON.stringify(editorState.nodePositions || {})),
                action: { type: actionType, description, nodeId, dataBefore, dataAfter }
            };
            redoStack = [];
            if (historyStack.length >= MAX_HISTORY) {
                historyStack.shift();
            }
            historyStack.push(stateSnapshot);
            setUnsavedChanges(true);
        }
        function undo() {
            if (historyStack.length === 0) return false;
            const prevState = historyStack.pop();
            redoStack.push({
                storyData: JSON.parse(JSON.stringify(storyData)),
                nodePositions: JSON.parse(JSON.stringify(editorState.nodePositions || {})),
                action: prevState.action
            });
            storyData = prevState.storyData;
            editorState.nodePositions = prevState.nodePositions;
            populateNodeList();
            renderVisualization();
            setTimeout(() => {
                applySavedPositions();
                if (prevState.action.nodeId && storyData[prevState.action.nodeId]) {
                    document.querySelector('.node-details').style.display = 'flex';
                    selectNode(prevState.action.nodeId);
                } else {
                    document.querySelector('.node-details').style.display = 'none';
                    editorState.lastSelectedNode = null;
                    if (cy) {
                        cy.$('node:selected').unselect();
                        cy.elements('.highlighted-edge').removeClass('highlighted-edge');
                    }
                }
            }, 100);
            setUnsavedChanges(true);
            showStatus(`–û—Ç–º–µ–Ω–µ–Ω–æ: ${prevState.action.description}`, "success");
            return true;
        }
        function redo() {
            if (redoStack.length === 0) return false;
            const nextState = redoStack.pop();
            historyStack.push({
                storyData: JSON.parse(JSON.stringify(storyData)),
                nodePositions: JSON.parse(JSON.stringify(editorState.nodePositions || {})),
                action: nextState.action
            });
            storyData = nextState.storyData;
            editorState.nodePositions = nextState.nodePositions;
            populateNodeList();
            renderVisualization();
            setTimeout(() => {
                applySavedPositions();
                if (nextState.action.nodeId && storyData[nextState.action.nodeId]) {
                    document.querySelector('.node-details').style.display = 'flex';
                    selectNode(nextState.action.nodeId);
                } else {
                    document.querySelector('.node-details').style.display = 'none';
                    editorState.lastSelectedNode = null;
                    if (cy) {
                        cy.$('node:selected').unselect();
                        cy.elements('.highlighted-edge').removeClass('highlighted-edge');
                    }
                }
            }, 100);
            setUnsavedChanges(true);
            showStatus(`–ü–æ–≤—Ç–æ—Ä–µ–Ω–æ: ${nextState.action.description}`, "success");
            return true;
        }
        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = function (event) {
                    console.error('Error opening IndexedDB:', event.target.error);
                    reject(event.target.error);
                };
                request.onsuccess = function (event) {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };
                request.onupgradeneeded = function (event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        function initVisualization() {
            if (cy) {
                cy.destroy();
            }
            let tagContainer = document.getElementById('tag-container');
            if (!tagContainer) {
                tagContainer = document.createElement('div');
                tagContainer.id = 'tag-container';
                tagContainer.style.position = 'absolute';
                tagContainer.style.top = '0';
                tagContainer.style.left = '0';
                tagContainer.style.width = '100%';
                tagContainer.style.height = '100%';
                tagContainer.style.pointerEvents = 'none';
                tagContainer.style.zIndex = '1000';
                document.getElementById('cy').appendChild(tagContainer);
            }
            let iconContainer = document.getElementById('item-icons-container');
            if (!iconContainer) {
                iconContainer = document.createElement('div');
                iconContainer.id = 'item-icons-container';
                iconContainer.style.position = 'absolute';
                iconContainer.style.top = '0';
                iconContainer.style.left = '0';
                iconContainer.style.width = '100%';
                iconContainer.style.height = '100%';
                iconContainer.style.pointerEvents = 'none';
                iconContainer.style.zIndex = '1001';
                document.getElementById('cy').appendChild(iconContainer);
            }
            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': function (ele) {
                                return ele.data('color') || '#4cc9f0';
                            },
                            'label': 'data(id)',
                            'color': 'white',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'width': '60px',
                            'height': '60px',
                            'font-size': '12px',
                            'text-wrap': 'wrap',
                            'text-max-width': '50px',
                            'z-index': 9999
                        }
                    },
                    {
                        selector: ':hover',
                        style: {
                            'background-color': '#4ade80'
                        }
                    },
                    {
                        selector: 'node:selected',
                        style: {
                            'background-color': '#fbbf24',
                            'border-width': '2px',
                            'border-color': '#f59e0b',
                            'z-index': 10000
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 3,
                            'line-color': '#ffb6c1',
                            'target-arrow-color': '#ffb6c1',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'color': '#ffffff',
                            'font-size': '10px',
                            'text-background-color': '#0d1b2a',
                            'text-background-opacity': 0.7,
                            'text-background-shape': 'rectangle',
                            'text-background-padding': '3px',
                            'text-border-width': 1,
                            'text-border-color': '#415a77'
                        }
                    },
                    {
                        selector: 'edge:selected',
                        style: {
                            'line-color': '#ff6b6b',
                            'target-arrow-color': '#ff6b6b',
                            'width': 4
                        }
                    },
                    {
                        selector: '.highlighted-edge',
                        style: {
                            'line-color': '#de4aa8',
                            'target-arrow-color': '#de4aa8',
                            'width': 8
                        }
                    },
                    {
                        selector: '.dice-edge',
                        style: {
                            'width': 3,
                            'line-color': '#3b82f6',
                            'target-arrow-color': '#3b82f6',
                            'line-style': 'dashed',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier',
                            'label': 'data(label)',
                            'color': '#a0c4ff',
                            'font-size': '18px',
                            'text-background-color': '#0d1b2a',
                            'text-background-opacity': 0.8,
                            'text-background-shape': 'rectangle',
                            'text-background-padding': '3px'
                        }
                    },
                    {
                        selector: '.key-require-edge',
                        style: {
                            'width': 4,
                            'line-color': '#FFD700',
                            'target-arrow-color': '#FFD700',
                            'curve-style': 'unbundled-bezier',
                            'control-point-step-size': 120,
                            'control-point-distances': [180, -180],
                            'line-style': 'solid',
                            'z-index': 900,
                            'opacity': 0.95
                        }
                    },
                    {
                        selector: 'edge[label]',
                        style: {
                            'label': 'data(label)'
                        }
                    },
                    {
                        selector: '.key-require-edge',
                        style: {
                            'label': ''
                        }
                    },
                    {
                        selector: '.password-edge',
                        style: {
                            'width': 4,
                            'line-color': '#ff0000',
                            'target-arrow-color': '#ff0000',
                            'curve-style': 'bezier',
                            'label': 'üîí',
                            'color': '#ff0000',
                            'font-size': '30px',
                            'text-background-color': '#0d1b2a',
                            'text-background-opacity': 0.7,
                            'text-background-shape': 'rectangle',
                            'text-background-padding': '5px',
                            'z-index': 1000
                        }
                    }
                ],
                layout: {
                    name: 'cose',
                    idealEdgeLength: 100,
                    nodeOverlap: 20,
                    refresh: 20,
                    fit: true,
                    padding: 30,
                    randomize: false,
                    componentSpacing: 100,
                    nodeSeparation: 75,
                    animate: true,
                    animationDuration: 1000
                },
                userZoomingEnabled: true,
                userPanningEnabled: true,
                boxSelectionEnabled: true,
                autounselectify: false,
                minZoom: 0.001,
                maxZoom: 1.5,
                wheelSensitivity: 0.5
            });
            cy.on('tap', function (evt) {
                if (evt.target === cy) {
                    cy.$(':selected').unselect();
                    cy.elements('.highlighted-edge').removeClass('highlighted-edge');
                    document.querySelector('.node-details').style.display = 'none';
                    editorState.lastSelectedNode = null;
                    saveEditorState();
                }
            });
            cy.on('tap', 'node', function (evt) {
                const nodeId = evt.target.data('id');
                selectNode(nodeId);
                evt.stopPropagation();
            });
            cy.on('position', 'node', function (evt) {
                const node = evt.target;
                const nodeId = node.data('id');
                if (!editorState.nodePositions) editorState.nodePositions = {};
                editorState.nodePositions[nodeId] = {
                    x: node.position('x'),
                    y: node.position('y')
                };
            });
            cy.on('dragfree', 'node', function () {
                const nodeId = this.data('id');
                const posBefore = this.scratch('_posBefore') || null;
                const posAfter = { x: this.position('x'), y: this.position('y') };
                saveToHistory(
                    ACTION_TYPES.NODE_MOVE,
                    `–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —É–∑–ª–∞ ${nodeId}`,
                    posBefore,
                    posAfter,
                    nodeId
                );
                saveEditorState();
            });
            cy.on('drag', 'node', function () {
                this.scratch('_posBefore', {
                    x: this.position('x'),
                    y: this.position('y')
                });
            });
            let tooltipTimeout = null;
            const tooltip = document.getElementById('node-tooltip');
            if (tooltip) {
                cy.on('mouseover', 'node', function (event) {
                    const node = event.target;
                    const nodeId = node.data('id');
                    const nodeData = storyData[nodeId];
                    if (!nodeData) return;
                    if (tooltipTimeout) clearTimeout(tooltipTimeout);
                    tooltipTimeout = setTimeout(() => {
                        if (tooltip) {
                            tooltip.innerHTML = (nodeData.text || '').replace(/\n/g, '<br>');
                            tooltip.style.display = 'block';
                        }
                    }, 500);
                });
                cy.on('mousemove', 'node', function (event) {
                    if (tooltip && tooltip.style.display === 'block') {
                        const evt = event.originalEvent || event;
                        let left = (evt.clientX || 0) + 15;
                        let top = (evt.clientY || 0) + 15;
                        tooltip.style.left = left + 'px';
                        tooltip.style.top = top + 'px';
                    }
                });
                cy.on('mouseout tap drag select mousedown', 'node', function () {
                    if (tooltipTimeout) clearTimeout(tooltipTimeout);
                    if (tooltip) tooltip.style.display = 'none';
                });
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#cy') && tooltip) {
                        tooltip.style.display = 'none';
                    }
                });
            }
            function updateTagPositions() {
                const container = document.getElementById('tag-container');
                if (!container || !cy) return;
                const zoom = cy.zoom();
                const pan = cy.pan();
                const fontSize = Math.max(12, Math.min(24, 16 * zoom));
                const existingTags = new Map();
                Array.from(container.children).forEach(el => {
                    const nodeId = el.dataset.nodeId;
                    if (nodeId) existingTags.set(nodeId, el);
                });
                cy.nodes().forEach(node => {
                    const nodeId = node.data('id');
                    const tagText = node.data('tag');
                    if (!tagText || !tagText.trim()) {
                        if (existingTags.has(nodeId)) {
                            container.removeChild(existingTags.get(nodeId));
                            existingTags.delete(nodeId);
                        }
                        return;
                    }
                    let tagEl = existingTags.get(nodeId);
                    if (!tagEl) {
                        tagEl = document.createElement('div');
                        tagEl.className = 'tag-label';
                        tagEl.dataset.nodeId = nodeId;
                        tagEl.style.position = 'absolute';
                        tagEl.style.pointerEvents = 'none';
                        tagEl.style.visibility = 'hidden';
                        container.appendChild(tagEl);
                    }
                    tagEl.textContent = tagText;
                    tagEl.style.fontSize = `${fontSize}px`;
                    tagEl.style.visibility = 'hidden';
                    const width = tagEl.offsetWidth;
                    const height = tagEl.offsetHeight;
                    const pos = node.position();
                    const screenX = pos.x * zoom + pan.x;
                    const screenY = pos.y * zoom + pan.y;
                    const left = screenX - width / 2;
                    const top = screenY - height - 20 - (4 * zoom);
                    tagEl.style.left = `${left}px`;
                    tagEl.style.top = `${top}px`;
                    tagEl.style.visibility = 'visible';
                    tagEl.style.setProperty('--tag-width', `${width}px`);
                    existingTags.delete(nodeId);
                });
                existingTags.forEach(tagEl => container.removeChild(tagEl));
            }
            cy.on('zoom pan render layoutstop drag', updateTagPositions);
            setTimeout(updateTagPositions, 500);
            function updateItemIcons() {
                const container = document.getElementById('item-icons-container');
                if (!container || !cy) return;
                const zoom = cy.zoom();
                const pan = cy.pan();
                const existingIcons = new Map();
                Array.from(container.children).forEach(el => {
                    const nodeId = el.dataset.nodeId;
                    if (nodeId) existingIcons.set(nodeId, el);
                });
                cy.nodes().forEach(node => {
                    const nodeId = node.data('id');
                    const nodeData = storyData[nodeId];
                    if (!nodeData) return;
                    let collectChoice = null;
                    if (nodeData.choices) {
                        nodeData.choices.forEach(choice => {
                            if (choice.collect) collectChoice = choice.collect;
                        });
                    }
                    const hasCollect = nodeData.collect || (nodeData.choices && nodeData.choices.some(c => c.collect));
                    const hasRequires = nodeData.requires || (nodeData.choices && nodeData.choices.some(c => c.requires));
                    const hasNpc = nodeData.tags && nodeData.tags.includes('npc');
                    if (!hasCollect && !hasRequires && !hasNpc) {
                        if (existingIcons.has(nodeId)) {
                            container.removeChild(existingIcons.get(nodeId));
                            existingIcons.delete(nodeId);
                        }
                        return;
                    }
                    let iconEl = existingIcons.get(nodeId);
                    if (!iconEl) {
                        iconEl = document.createElement('div');
                        iconEl.className = 'item-icon-label';
                        iconEl.dataset.nodeId = nodeId;
                        iconEl.style.position = 'absolute';
                        iconEl.style.pointerEvents = 'none';
                        iconEl.style.visibility = 'hidden';
                        container.appendChild(iconEl);
                    }
                    let iconText = '';
                    const collect = collectChoice || nodeData.collect;
                    if (collect) {
                        const type = collect.type || 'regular';
                        const icons = { regular: 'üóùÔ∏è', card: 'üÉè', old: 'üîë', digital: 'üíæ' };
                        iconText += icons[type] || 'üóùÔ∏è';
                    }
                    if (hasRequires) {
                        iconText += 'üîí';
                    }
                    if (hasNpc) {
                        iconText += 'üë®‚ÄçüöÄ';
                    }
                    iconEl.textContent = iconText;
                    iconEl.style.fontSize = `${Math.max(14, 20 * zoom)}px`;
                    iconEl.style.visibility = 'hidden';
                    const pos = node.position();
                    const screenX = pos.x * zoom + pan.x;
                    const screenY = pos.y * zoom + pan.y;
                    const left = screenX - (iconEl.offsetWidth / 2);
                    const top = screenY - 60;
                    iconEl.style.left = `${left}px`;
                    iconEl.style.top = `${top}px`;
                    iconEl.style.visibility = 'visible';
                    existingIcons.delete(nodeId);
                });
                existingIcons.forEach(el => container.removeChild(el));
            }
            cy.on('zoom pan render layoutstop dragfree', updateItemIcons);
            setTimeout(updateItemIcons, 600);
        }
        function setupResizer() {
            const resizer = document.getElementById('resizer');
            const container = document.getElementById('container');
            const editor = document.getElementById('editor');
            const visualization = document.getElementById('visualization');
            let startX;
            let startWidth;
            resizer.addEventListener('mousedown', function (e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(document.defaultView.getComputedStyle(editor).width, 10);
                document.documentElement.style.cursor = 'col-resize';
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            });
            function resize(e) {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                const newWidth = startWidth + dx;
                const containerWidth = container.offsetWidth;
                if (newWidth > editorMinWidth && newWidth < (containerWidth - visualizationMinWidth)) {
                    editor.style.width = newWidth + 'px';
                    visualization.style.width = (containerWidth - newWidth - 10) + 'px';
                    editorState.editorWidth = (newWidth / containerWidth) * 100;
                    editorState.visualizationWidth = 100 - editorState.editorWidth;
                    if (cy) cy.resize();
                    setUnsavedChanges(true);
                }
            }
            function stopResize() {
                isResizing = false;
                document.documentElement.style.cursor = 'default';
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
                saveEditorState();
            }
            window.addEventListener('resize', function () {
                if (cy) cy.resize();
            });
        }
        function highlightConnectedEdges(nodeId) {
            if (!cy) return;
            cy.elements('.highlighted-edge').removeClass('highlighted-edge');
            if (!nodeId) return;
            const startNode = cy.getElementById(nodeId);
            if (startNode.empty()) return;
            let edgesToHighlight = cy.collection();
            const step1Forward = startNode.outgoers('edge');
            const nodes1Forward = step1Forward.targets();
            const step2Forward = nodes1Forward.outgoers('edge');
            const step1Backward = startNode.incomers('edge');
            const nodes1Backward = step1Backward.sources();
            const step2Backward = nodes1Backward.incomers('edge');
            edgesToHighlight = edgesToHighlight
                .merge(step1Forward)
                .merge(step2Forward)
                .merge(step1Backward)
                .merge(step2Backward);
            edgesToHighlight.addClass('highlighted-edge');
        }
        // ==== –û–ë–ù–û–í–õ–Å–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø selectNode ====
        function selectNode(nodeId) {
            if (!storyData[nodeId]) {
                showStatus(`–£–∑–µ–ª ${nodeId} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –¥–∞–Ω–Ω—ã—Ö`, "error");
                return;
            }
            document.getElementById('node-id').textContent = nodeId;
            document.getElementById('node-text').value = storyData[nodeId].text || '';

            // === –ü–ê–†–û–õ–¨–ù–´–ô –£–ó–ï–õ ===
            const isPasswordNode = storyData[nodeId].input_type === 'code';
            const passwordCheckbox = document.getElementById('node-password-checkbox');
            const passwordFields = document.getElementById('password-fields');
            const nodeText = document.getElementById('node-text');
            passwordCheckbox.checked = isPasswordNode;
            passwordFields.style.display = isPasswordNode ? 'block' : 'none';
            nodeText.style.display = isPasswordNode ? 'none' : 'block';
            nodeText.value = isPasswordNode ? '' : (storyData[nodeId].text || '');

            // === –õ–û–ö–ê–¶–ò–û–ù–ù–´–ô –£–ó–ï–õ ===
            const isLocationNode = !!storyData[nodeId].is_location;
            const locationCheckbox = document.getElementById('node-is-location-checkbox');
            const locationFields = document.getElementById('location-fields');
            locationCheckbox.checked = isLocationNode;
            locationFields.style.display = isLocationNode ? 'block' : 'none';

            if (isLocationNode) {
                document.getElementById('location_name').value = storyData[nodeId].location_name || '';
                document.getElementById('location_category').value = storyData[nodeId].location_category || '';
                document.getElementById('category_name').value = storyData[nodeId].category_name || '';
                document.getElementById('location_description').value = storyData[nodeId].location_description || '';
                document.getElementById('location_icon').value = storyData[nodeId].location_icon || 'üèõÔ∏è';

                // –í—ã–¥–µ–ª–∏—Ç—å –∏–∫–æ–Ω–∫—É
                const iconValue = storyData[nodeId].location_icon || 'üèõÔ∏è';
                document.querySelectorAll('.location-icon-item').forEach(el => {
                    el.classList.toggle('selected', el.textContent === iconValue);
                });
            } else {
                document.getElementById('location_name').value = '';
                document.getElementById('location_category').value = '';
                document.getElementById('category_name').value = '';
                document.getElementById('location_description').value = '';
                document.getElementById('location_icon').value = 'üèõÔ∏è';
            }

            // === NPC CHECKBOX ===
            const isNpcNode = !!(storyData[nodeId].tags && storyData[nodeId].tags.includes('npc'));
            const npcCheckbox = document.getElementById('node-is-npc-checkbox');
            if (npcCheckbox) {
                npcCheckbox.checked = isNpcNode;
            }

            // === –í–´–ë–û–†–û–ß–ù–´–ï –ü–û–õ–Ø ===
            const choicesContainer = document.getElementById('choices-container');
            const choicesList = choicesContainer.querySelector('#choices-list');
            if (choicesList) choicesList.remove();
            if (!isPasswordNode) {
                const choicesListDiv = document.createElement('div');
                choicesListDiv.id = 'choices-list';
                (storyData[nodeId].choices || []).forEach((choice, index) => {
                    let isDice = false;
                    let nextValue = choice.next || '';
                    if (typeof nextValue === 'string' && nextValue.startsWith('DICE:')) {
                        isDice = true;
                        nextValue = nextValue.slice(5);
                    }
                    const collectChoice = choice.collect || {};
                    const requiresChoice = choice.requires || [];
                    const missingMessages = choice.missingMessages || {};
                    let requiresInputValue = '';
                    if (Array.isArray(requiresChoice)) {
                        requiresInputValue = requiresChoice.join(', ');
                    } else if (requiresChoice) {
                        requiresInputValue = requiresChoice;
                    }
                    const choiceDiv = document.createElement('div');
                    choiceDiv.className = 'choice-item';
                    choiceDiv.innerHTML = `
<label>–¢–µ–∫—Å—Ç –≤–∞—Ä–∏–∞–Ω—Ç–∞ ${index + 1}:</label>
<textarea class="choice-text" data-index="${index}" rows="2">${choice.text || ''}</textarea>
<label>–°–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª:</label>
<input type="text" class="choice-next" data-index="${index}" value="${nextValue}">
<label style="display: flex; align-items: center; gap: 6px; margin-top: 6px;">
<input type="checkbox" class="choice-dice" data-index="${index}" ${isDice ? 'checked' : ''}>
DICE ‚Äî –±—Ä–æ—Å–æ–∫ –∫—É–±–∏–∫–æ–≤ (—É–∫–∞–∂–∏—Ç–µ —Ç—Ä–∏ ID —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é: —É—Å–ø–µ—Ö,—á–∞—Å—Ç–∏—á–Ω—ã–π,–ø—Ä–æ–≤–∞–ª)
</label>
<!-- –°–ë–û–† –ü–†–ï–î–ú–ï–¢–ê –ù–ê –£–†–û–í–ù–ï –í–´–ë–û–†–ê -->
<div class="collect-requires-group" style="margin-top: 12px;">
<label>
<input type="checkbox" class="choice-collect-checkbox" data-index="${index}" ${collectChoice.id ? 'checked' : ''}>
–°–æ–±—Ä–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç –ø—Ä–∏ —ç—Ç–æ–º –≤—ã–±–æ—Ä–µ
</label>
<div class="choice-collect-fields" style="display: ${collectChoice.id ? 'block' : 'none'}; margin-top: 8px; padding: 8px; background: #0d1b2a; border-radius: 5px;">
<div><label>ID:</label> <input type="text" class="choice-collect-id" data-index="${index}" value="${collectChoice.id || ''}"></div>
<div><label>–ù–∞–∑–≤–∞–Ω–∏–µ:</label> <input type="text" class="choice-collect-label" data-index="${index}" value="${collectChoice.label || ''}"></div>
<div><label>–¢–∏–ø:</label>
<select class="choice-collect-type" data-index="${index}">
<option value="regular" ${collectChoice.type === 'regular' ? 'selected' : ''}>–û–±—ã—á–Ω—ã–π (üóùÔ∏è)</option>
<option value="card" ${collectChoice.type === 'card' ? 'selected' : ''}>–ö–∞—Ä—Ç–∞ (üÉè)</option>
<option value="old" ${collectChoice.type === 'old' ? 'selected' : ''}>–°—Ç–∞—Ä—ã–π –∫–ª—é—á (üîë)</option>
<option value="digital" ${collectChoice.type === 'digital' ? 'selected' : ''}>–¶–∏—Ñ—Ä–æ–≤–æ–π (üíæ)</option>
</select>
</div>
</div>
</div>
<!-- –¢–†–ï–ë–û–í–ê–ù–ò–ï –ü–†–ï–î–ú–ï–¢–ê –ù–ê –£–†–û–í–ù–ï –í–´–ë–û–†–ê -->
<div class="collect-requires-group" style="margin-top: 12px;">
<label>
<input type="checkbox" class="choice-requires-checkbox" data-index="${index}" ${requiresInputValue ? 'checked' : ''}>
–¢—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è —ç—Ç–æ–≥–æ –≤—ã–±–æ—Ä–∞
</label>
<div class="choice-requires-fields" style="display: ${requiresInputValue ? 'block' : 'none'}; margin-top: 8px;">
<div><label>ID –ø—Ä–µ–¥–º–µ—Ç–æ–≤ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):</label>
<input type="text" class="choice-requires-id" data-index="${index}" value="${requiresInputValue}">
</div>
<div style="margin-top: 10px;">
<label>–°–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –∫–ª—é—á–µ–π:</label>
<div class="missing-messages-container" data-index="${index}"></div>
<button type="button" class="add-missing-msg-btn" data-index="${index}" style="margin-top: 6px; font-size: 13px;">+ –î–æ–±–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</button>
</div>
</div>
</div>
<div class="choice-controls">
<button class="delete-choice" data-index="${index}">–£–¥–∞–ª–∏—Ç—å</button>
</div>
`;
                    choicesListDiv.appendChild(choiceDiv);
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π –≤—ã–±–æ—Ä–∞ collect/require
                    const collectCheckbox = choiceDiv.querySelector('.choice-collect-checkbox');
                    const collectFields = choiceDiv.querySelector('.choice-collect-fields');
                    if (collectCheckbox) {
                        collectCheckbox.addEventListener('change', () => {
                            collectFields.style.display = collectCheckbox.checked ? 'block' : 'none';
                        });
                    }
                    const requiresCheckbox = choiceDiv.querySelector('.choice-requires-checkbox');
                    const requiresFields = choiceDiv.querySelector('.choice-requires-fields');
                    if (requiresCheckbox) {
                        requiresCheckbox.addEventListener('change', () => {
                            requiresFields.style.display = requiresCheckbox.checked ? 'block' : 'none';
                        });
                    }
                    const container = choiceDiv.querySelector('.missing-messages-container');
                    const addBtn = choiceDiv.querySelector('.add-missing-msg-btn');
                    if (addBtn) {
                        addBtn.addEventListener('click', () => {
                            const requiresInput = choiceDiv.querySelector('.choice-requires-id');
                            const ids = (requiresInput.value || '')
                                .split(',')
                                .map(s => s.trim())
                                .filter(s => s);
                            if (ids.length === 0) {
                                addMissingMessageField(container);
                            } else {
                                ids.forEach(keyId => {
                                    if (!container.querySelector(`.missing-key-id[value="${keyId}"]`)) {
                                        addMissingMessageField(container, keyId);
                                    }
                                });
                            }
                        });
                    }
                    for (const keyId in missingMessages) {
                        const msg = missingMessages[keyId];
                        addMissingMessageField(container, keyId, msg);
                    }
                    const deleteBtn = choiceDiv.querySelector('.delete-choice');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', () => {
                            choiceDiv.remove();
                        });
                    }
                });
                choicesContainer.appendChild(choicesListDiv);
            } else {
                choicesContainer.innerHTML = '<h4>–í–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–±–æ—Ä–∞:</h4>';
            }

            // === –ü–û–õ–Ø –ü–ê–†–û–õ–Ø ===
            if (isPasswordNode) {
                document.getElementById('code_title').value = storyData[nodeId].code_title || '';
                document.getElementById('code_hint').value = storyData[nodeId].code_hint || '';
                document.getElementById('correct_code').value = storyData[nodeId].correct_code || '';
                document.getElementById('case_sensitive').checked = !!storyData[nodeId].case_sensitive;
                document.getElementById('error_message').value = storyData[nodeId].error_message || '';
                document.getElementById('success_next').value = storyData[nodeId].success_next || '';
            } else {
                document.getElementById('code_title').value = '';
                document.getElementById('code_hint').value = '';
                document.getElementById('correct_code').value = '';
                document.getElementById('case_sensitive').checked = false;
                document.getElementById('error_message').value = '';
                document.getElementById('success_next').value = '';
            }

            // === –¶–í–ï–¢ –ò –¢–ï–ì ===
            const colorPicker = document.getElementById('node-color');
            const colorPreview = document.getElementById('color-preview');
            const nodeColor = storyData[nodeId].color || '#4cc9f0';
            colorPicker.value = nodeColor;
            colorPreview.style.backgroundColor = nodeColor;
            if (document.getElementById('node-color-hex')) {
                document.getElementById('node-color-hex').value = nodeColor;
            }
            const tagField = document.getElementById('node-tag');
            if (tagField) {
                tagField.value = storyData[nodeId].tag || '';
            }

            document.querySelector('.node-details').style.display = 'flex';
            if (cy) {
                cy.$('node:selected').unselect();
                const node = cy.getElementById(nodeId);
                if (node.length > 0) {
                    node.select();
                    cy.animate({ fit: { eles: node, padding: 80 }, duration: 1000 });
                    highlightConnectedEdges(nodeId);
                    node.data('tag', storyData[nodeId].tag || '');
                }
            }
            document.getElementById('node-list').value = nodeId;
            editorState.lastSelectedNode = nodeId;
        }

        // ==== –§–£–ù–ö–¶–ò–ò –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô: populateNodeList –∏ —Ç.–¥. ====
        function populateNodeList() {
            const nodeList = document.getElementById('node-list');
            nodeList.innerHTML = '';
            const sortedNodeIds = Object.keys(storyData)
                .map(id => parseInt(id))
                .sort((a, b) => a - b)
                .map(id => id.toString());
            sortedNodeIds.forEach(nodeId => {
                const option = document.createElement('option');
                option.value = nodeId;
                const textPreview = storyData[nodeId].text.length > 50
                    ? storyData[nodeId].text.substring(0, 50) + '...'
                    : storyData[nodeId].text;
                const nodeColor = storyData[nodeId].color || '#4cc9f0';
                option.innerHTML = `<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background-color:${nodeColor};margin-right:8px;"></span>–£–∑–µ–ª ${nodeId}: ${textPreview}`;
                option.style.color = '#e6e6e6';
                nodeList.appendChild(option);
            });
        }
        function deleteSelectedNode(nodeId) {
            if (!nodeId || !storyData[nodeId]) return;
            const nodeData = JSON.parse(JSON.stringify(storyData[nodeId]));
            delete storyData[nodeId];
            for (const id in storyData) {
                storyData[id].choices = storyData[id].choices.filter(choice => choice.next !== nodeId);
                if (storyData[id].success_next === nodeId) {
                    delete storyData[id].success_next;
                }
            }
            populateNodeList();
            renderVisualization();
            document.querySelector('.node-details').style.display = 'none';
            editorState.lastSelectedNode = null;
            if (cy) {
                cy.$('node:selected').unselect();
                cy.elements('.highlighted-edge').removeClass('highlighted-edge');
            }
            saveToHistory(
                ACTION_TYPES.NODE_DELETE,
                `–£–¥–∞–ª–µ–Ω–∏–µ —É–∑–ª–∞ ${nodeId}`,
                { nodeId, nodeData },
                null,
                nodeId
            );
            showStatus(`–£–∑–µ–ª ${nodeId} —É–¥–∞–ª—ë–Ω`, "success");
        }
        function saveEditorState() {
            if (!editorState.autoSave) return;
            try {
                const stateToSave = {
                    lastSelectedNode: editorState.lastSelectedNode,
                    nodePositions: editorState.nodePositions,
                    editorWidth: editorState.editorWidth,
                    visualizationWidth: editorState.visualizationWidth,
                    lastModified: new Date().toISOString(),
                    autoSave: editorState.autoSave,
                    storyData: JSON.parse(JSON.stringify(storyData))
                };
                localStorage.setItem('storyEditorState', JSON.stringify(stateToSave));
                if (db) {
                    const defaultStateName = 'default_story_state';
                    saveStateToDB(defaultStateName, stateToSave)
                        .then(() => {
                            editorState.lastSaved = new Date().toISOString();
                            hasUnsavedChanges = false;
                            updateStatus();
                        })
                        .catch(error => {
                            console.error("Error saving to IndexedDB:", error);
                        });
                } else {
                    editorState.lastSaved = new Date().toISOString();
                    hasUnsavedChanges = false;
                    updateStatus();
                }
            } catch (e) {
                console.error("Error saving editor state:", e);
                showStatus("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è", "error");
            }
        }
        function saveStateToDB(stateName, stateData) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    resolve();
                    return;
                }
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(stateData, stateName);
                request.onsuccess = function () {
                    resolve();
                };
                request.onerror = function (event) {
                    reject(event.target.error);
                };
            });
        }
        async function loadEditorState() {
            try {
                let loadedState = null;
                if (db) {
                    const defaultStateName = 'default_story_state';
                    try {
                        loadedState = await loadStateFromDB(defaultStateName);
                    } catch (error) {
                        console.error("Error loading from IndexedDB:", error);
                    }
                }
                if (!loadedState) {
                    const savedState = localStorage.getItem('storyEditorState');
                    if (savedState) {
                        loadedState = JSON.parse(savedState);
                    }
                }
                if (loadedState) {
                    editorState = {
                        ...editorState,
                        lastSelectedNode: loadedState.lastSelectedNode,
                        nodePositions: loadedState.nodePositions || {},
                        editorWidth: loadedState.editorWidth || 40,
                        visualizationWidth: loadedState.visualizationWidth || 60,
                        lastSaved: loadedState.lastModified,
                        autoSave: loadedState.autoSave !== undefined ? loadedState.autoSave : true
                    };
                    if (loadedState.storyData) {
                        storyData = loadedState.storyData;
                        populateNodeList();
                        renderVisualization();
                        setTimeout(() => {
                            applySavedPositions();
                        }, 100);
                    }
                    document.getElementById('auto-save-checkbox').checked = editorState.autoSave;
                    if (loadedState.editorWidth) {
                        const container = document.getElementById('container');
                        const editor = document.getElementById('editor');
                        const visualization = document.getElementById('visualization');
                        editor.style.width = loadedState.editorWidth + '%';
                        visualization.style.width = loadedState.visualizationWidth + '%';
                    }
                    updateStatus();
                    return true;
                }
            } catch (e) {
                console.error("Error loading editor state:", e);
            }
            return false;
        }
        function loadStateFromDB(stateName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    resolve(null);
                    return;
                }
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(stateName);
                request.onsuccess = function (event) {
                    resolve(event.target.result || null);
                };
                request.onerror = function (event) {
                    reject(event.target.error);
                };
            });
        }
        function saveStateToFile() {
            const stateToSave = {
                storyData: storyData,
                editorState: {
                    lastSelectedNode: editorState.lastSelectedNode,
                    nodePositions: editorState.nodePositions,
                    editorWidth: editorState.editorWidth,
                    visualizationWidth: editorState.visualizationWidth,
                    lastModified: new Date().toISOString()
                }
            };
            const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
            saveAs(blob, 'story_editor_state.storystate');
        }
        function loadStateFromFile(file) {
            const reader = new FileReader();
            reader.onload = function (event) {
                try {
                    const state = JSON.parse(event.target.result);
                    if (!state.storyData || !state.editorState) {
                        throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è");
                    }
                    const oldData = JSON.parse(JSON.stringify(storyData));
                    storyData = state.storyData;
                    editorState = {
                        ...editorState,
                        lastSelectedNode: state.editorState.lastSelectedNode,
                        nodePositions: state.editorState.nodePositions || {},
                        editorWidth: state.editorState.editorWidth || 40,
                        visualizationWidth: state.editorState.visualizationWidth || 60,
                        lastSaved: state.editorState.lastModified
                    };
                    if (state.storyData) {
                        storyData = JSON.parse(JSON.stringify(state.storyData));
                        populateNodeList();
                        renderVisualization();
                        setTimeout(() => {
                            applySavedPositions();
                        }, 100);
                    }
                    if (state.editorState.editorWidth) {
                        const container = document.getElementById('container');
                        const editor = document.getElementById('editor');
                        const visualization = document.getElementById('visualization');
                        editor.style.width = state.editorState.editorWidth + '%';
                        visualization.style.width = state.editorState.visualizationWidth + '%';
                    }
                    populateNodeList();
                    renderVisualization();
                    setTimeout(() => {
                        applySavedPositions();
                    }, 300);
                    saveToHistory(
                        ACTION_TYPES.FULL_DATA_REPLACE,
                        "–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–∞",
                        oldData,
                        storyData
                    );
                    showStatus("–°–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ —Ñ–∞–π–ª–∞!", "success");
                    hasUnsavedChanges = false;
                    updateStatus();
                } catch (error) {
                    showStatus(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è: ${error.message}`, "error");
                    console.error("Error loading state from file:", error);
                }
            };
            reader.onerror = function () {
                showStatus("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è", "error");
            };
            reader.readAsText(file);
        }
        function applySavedPositions() {
            if (!cy || !editorState.nodePositions) return;
            cy.nodes().forEach(node => {
                const nodeId = node.data('id');
                if (editorState.nodePositions[nodeId]) {
                    node.position({
                        x: editorState.nodePositions[nodeId].x,
                        y: editorState.nodePositions[nodeId].y
                    });
                }
            });
            cy.resize();
        }
        function loadData(jsonData) {
            const oldData = JSON.parse(JSON.stringify(storyData));
            storyData = {};
            Object.keys(jsonData).forEach(id => {
                storyData[id] = {
                    ...jsonData[id],
                    tag: jsonData[id].tag || ''
                };
            });
            populateNodeList();
            renderVisualization();
            saveToHistory(
                ACTION_TYPES.FULL_DATA_REPLACE,
                "–ò–º–ø–æ—Ä—Ç JSON",
                oldData,
                storyData
            );
            showStatus("JSON —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω!", "success");
            setUnsavedChanges(false);
        }
        function validateJsonStructure(json) {
            if (typeof json !== 'object' || json === null) return false;
            for (const key in json) {
                if (typeof json[key] !== 'object' || json[key] === null) return false;
                if (typeof json[key].text !== 'string') return false;
                if (!Array.isArray(json[key].choices)) return false;
                for (const choice of json[key].choices) {
                    if (typeof choice !== 'object' || choice === null) return false;
                    if (typeof choice.text !== 'string') return false;
                    if (typeof choice.next !== 'string' && choice.next !== null && choice.next !== undefined) return false;
                }
            }
            return true;
        }
        function renderVisualization() {
            if (!cy) return;
            cy.elements().remove();
            const elements = { nodes: [], edges: [] };
            const addedNodeIds = new Set();
            Object.keys(storyData).forEach(nodeId => {
                if (!addedNodeIds.has(nodeId)) {
                    const nodeColor = storyData[nodeId].color || '#4cc9f0';
                    const nodeTag = storyData[nodeId].tag || '';
                    let hasDice = false;
                    (storyData[nodeId].choices || []).forEach(choice => {
                        if (typeof choice.next === 'string' && choice.next.startsWith('DICE:')) {
                            hasDice = true;
                        }
                    });
                    const finalColor = hasDice ? '#3b82f6' : nodeColor;
                    elements.nodes.push({
                        data: { id: nodeId, color: finalColor, tag: nodeTag },
                        position: editorState.nodePositions[nodeId] || undefined
                    });
                    addedNodeIds.add(nodeId);
                }
                (storyData[nodeId].choices || []).forEach(choice => {
                    if (!choice.next) return;
                    if (typeof choice.next === 'string' && choice.next.startsWith('DICE:')) {
                        const parts = choice.next.slice(5).split(',').map(id => id.trim());
                        const [success, partial, fail] = parts;
                        [success, partial, fail].forEach(targetId => {
                            if (!targetId) return;
                            if (!addedNodeIds.has(targetId)) {
                                const targetColor = storyData[targetId]?.color || '#4cc9f0';
                                const targetTag = storyData[targetId]?.tag || '';
                                elements.nodes.push({
                                    data: { id: targetId, color: targetColor, tag: targetTag },
                                    position: editorState.nodePositions[targetId] || undefined
                                });
                                addedNodeIds.add(targetId);
                            }
                            elements.edges.push({
                                data: {
                                    id: `${nodeId}-dice-${targetId}`,
                                    source: nodeId,
                                    target: targetId,
                                    label: targetId === success ? '‚â•8' : targetId === partial ? '=7' : '‚â§6'
                                },
                                classes: 'dice-edge'
                            });
                        });
                    } else {
                        const targetId = choice.next;
                        if (targetId && !addedNodeIds.has(targetId)) {
                            const targetColor = storyData[targetId]?.color || '#4cc9f0';
                            const targetTag = storyData[targetId]?.tag || '';
                            elements.nodes.push({
                                data: { id: targetId, color: targetColor, tag: targetTag },
                                position: editorState.nodePositions[targetId] || undefined
                            });
                            addedNodeIds.add(targetId);
                        }
                        elements.edges.push({
                            data: {
                                id: `${nodeId}-${targetId}`,
                                source: nodeId,
                                target: targetId,
                                label: choice.text.substring(0, 15) + (choice.text.length > 15 ? '...' : '')
                            }
                        });
                    }
                });
            });
            const collectMap = new Map();
            Object.keys(storyData).forEach(nodeId => {
                const node = storyData[nodeId];
                if (node.collect && node.collect.id) {
                    collectMap.set(node.collect.id, nodeId);
                }
                if (node.choices) {
                    node.choices.forEach(choice => {
                        if (choice.collect && choice.collect.id) {
                            collectMap.set(choice.collect.id, nodeId);
                        }
                    });
                }
            });
            const requireEntries = [];
            Object.keys(storyData).forEach(nodeId => {
                const node = storyData[nodeId];
                if (node.requires) {
                    let reqList = [];
                    if (Array.isArray(node.requires)) {
                        reqList = node.requires;
                    } else if (typeof node.requires === 'string') {
                        reqList = [node.requires];
                    }
                    reqList.forEach(reqId => {
                        if (reqId) {
                            requireEntries.push({ nodeId: nodeId, reqId: reqId.trim() });
                        }
                    });
                }
                if (node.choices) {
                    node.choices.forEach(choice => {
                        if (choice.requires) {
                            let reqList = [];
                            if (Array.isArray(choice.requires)) {
                                reqList = choice.requires;
                            } else if (typeof choice.requires === 'string') {
                                reqList = [choice.requires];
                            }
                            reqList.forEach(reqId => {
                                if (reqId) {
                                    requireEntries.push({ nodeId: nodeId, reqId: reqId.trim() });
                                }
                            });
                        }
                    });
                }
            });
            requireEntries.forEach(entry => {
                const { nodeId: toNodeId, reqId } = entry;
                const fromNodeId = collectMap.get(reqId);
                if (fromNodeId && fromNodeId !== toNodeId) {
                    const edgeId = `keylink-${fromNodeId}-${toNodeId}`;
                    if (!elements.edges.some(e => e.data.id === edgeId)) {
                        elements.edges.push({
                            data: { id: edgeId, source: fromNodeId, target: toNodeId },
                            classes: 'key-require-edge'
                        });
                    }
                }
            });
            Object.keys(storyData).forEach(nodeId => {
                const node = storyData[nodeId];
                if (node.input_type === 'code' && node.success_next) {
                    const targetId = node.success_next;
                    if (targetId && !addedNodeIds.has(targetId)) {
                        const targetColor = storyData[targetId]?.color || '#4cc9f0';
                        const targetTag = storyData[targetId]?.tag || '';
                        elements.nodes.push({
                            data: { id: targetId, color: targetColor, tag: targetTag },
                            position: editorState.nodePositions[targetId] || undefined
                        });
                        addedNodeIds.add(targetId);
                    }
                    const edgeId = `password-${nodeId}-${targetId}`;
                    if (!elements.edges.some(e => e.data.id === edgeId)) {
                        elements.edges.push({
                            data: {
                                id: edgeId,
                                source: nodeId,
                                target: targetId,
                                label: 'üîí'
                            },
                            classes: 'password-edge'
                        });
                    }
                }
            });
            cy.add(elements.nodes);
            cy.add(elements.edges);
            if (Object.keys(editorState.nodePositions).length > 0 && cy.elements().length > 0) {
                applySavedPositions();
            } else if (cy.elements().length > 0) {
                cy.layout({ name: 'cose' }).run();
                cy.animate({ fit: { eles: cy.elements(), padding: 50 }, duration: 1000 });
            }
        }
        function loadTestData() {
            storyData = {
                "0": {
                    "text": "–ù–∞—á–∞–ª–æ –∏—Å—Ç–æ—Ä–∏–∏.",
                    "choices": [{ "text": "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å", "next": "1" }],
                    "color": "#4cc9f0",
                    "tag": "–ù–∞—á–∞–ª–æ"
                },
                "1": {
                    "text": "–í—ã –≤–∏–¥–∏—Ç–µ –∫–ª—é—á –Ω–∞ —Å—Ç–æ–ª–µ.",
                    "choices": [
                        {
                            "text": "–ü–æ–¥–æ–±—Ä–∞—Ç—å –∫–ª—é—á",
                            "next": "2",
                            "collect": { "id": "arch", "label": "–ö–ª—é—á –æ—Ç –∞—Ä—Ö–∏–≤–∞ –æ—Ç—Ü–∞", "type": "old" }
                        },
                        {
                            "text": "–£–π—Ç–∏",
                            "next": "2"
                        }
                    ],
                    "color": "#4cc9f0"
                },
                "2": {
                    "text": "–ó–∞–ø–µ—Ä—Ç–∞—è –¥–≤–µ—Ä—å.",
                    "choices": [
                        {
                            "text": "–û—Ç–∫—Ä—ã—Ç—å –¥–≤–µ—Ä—å",
                            "next": "3",
                            "requires": ["arch"],
                            "missingMessages": { "arch": "–ù—É–∂–µ–Ω –∫–ª—é—á –æ—Ç –∞—Ä—Ö–∏–≤–∞ –æ—Ç—Ü–∞" }
                        }
                    ],
                    "color": "#d32f2f"
                },
                "3": {
                    "text": "–í—ã –≤–æ—à–ª–∏!",
                    "choices": [],
                    "color": "#4caf50"
                }
            };
            populateNodeList();
            renderVisualization();
            showStatus("–¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã", "success");
            setUnsavedChanges(false);
        }
        // ==== –û–ë–ù–û–í–õ–Å–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –°–û–•–†–ê–ù–ï–ù–ò–Ø –£–ó–õ–ê ====
        document.getElementById('save-node').addEventListener('click', () => {
            const nodeId = document.getElementById('node-id').textContent;
            const oldData = JSON.parse(JSON.stringify(storyData[nodeId] || {}));
            const nodeText = document.getElementById('node-text').value.trim();
            const nodeColor = document.getElementById('node-color').value;
            const nodeTag = document.getElementById('node-tag').value.trim();
            const isPasswordNode = document.getElementById('node-password-checkbox').checked;
            const isLocationNode = document.getElementById('node-is-location-checkbox').checked;

            const choices = [];
            document.querySelectorAll('.choice-item').forEach((item) => {
                const textEl = item.querySelector('.choice-text');
                const nextEl = item.querySelector('.choice-next');
                const diceEl = item.querySelector('.choice-dice');
                let nextVal = (nextEl.value || '').trim();
                if (diceEl && diceEl.checked) {
                    nextVal = `DICE:${nextVal}`;
                }
                const choiceData = {
                    text: textEl.value || '',
                    next: nextVal
                };
                const collectCheckbox = item.querySelector('.choice-collect-checkbox');
                if (collectCheckbox && collectCheckbox.checked) {
                    const id = item.querySelector('.choice-collect-id').value.trim();
                    const label = item.querySelector('.choice-collect-label').value.trim();
                    const type = item.querySelector('.choice-collect-type').value;
                    if (id && label) {
                        choiceData.collect = { id, label, type };
                    }
                }
                const requiresCheckbox = item.querySelector('.choice-requires-checkbox');
                if (requiresCheckbox && requiresCheckbox.checked) {
                    const input = item.querySelector('.choice-requires-id').value.trim();
                    if (input) {
                        const ids = input
                            .split(',')
                            .map(s => s.trim())
                            .filter(s => s);
                        if (ids.length === 1) {
                            choiceData.requires = ids[0];
                        } else if (ids.length > 1) {
                            choiceData.requires = ids;
                        }
                        const missingMsgs = {};
                        const msgContainers = item.querySelectorAll('.missing-msg-item');
                        msgContainers.forEach(el => {
                            const keyId = el.querySelector('.missing-key-id').value.trim();
                            const msg = el.querySelector('.missing-key-msg').value.trim();
                            if (keyId && msg) {
                                missingMsgs[keyId] = msg;
                            }
                        });
                        if (Object.keys(missingMsgs).length > 0) {
                            choiceData.missingMessages = missingMsgs;
                        }
                    }
                }
                choices.push(choiceData);
            });

            let newData = {
                text: nodeText,
                choices: choices,
                color: nodeColor,
                tag: nodeTag
            };

            // === –õ–û–ö–ê–¶–ò–Ø ===
            if (isLocationNode) {
                newData.is_location = true;
                newData.location_name = document.getElementById('location_name').value.trim();
                newData.location_category = document.getElementById('location_category').value.trim();
                newData.category_name = document.getElementById('category_name').value.trim();
                newData.location_description = document.getElementById('location_description').value.trim();
                newData.location_icon = document.getElementById('location_icon').value.trim();
            }

            // === NPC ===
            const isNpcNode = document.getElementById('node-is-npc-checkbox')?.checked;
            if (isNpcNode) {
                if (!newData.tags) newData.tags = [];
                if (!newData.tags.includes('npc')) newData.tags.push('npc');
            } else {
                if (newData.tags) {
                    newData.tags = newData.tags.filter(t => t !== 'npc');
                    if (newData.tags.length === 0) delete newData.tags;
                }
            }

            // Password protection data
            const passwordEnabled = document.getElementById('node-password-checkbox').checked;
            if (passwordEnabled) {
                newData.input_type = "code";
                newData.code_title = document.getElementById('code-title').value;
                newData.code_hint = document.getElementById('code-hint').value;
                newData.correct_code = document.getElementById('correct-code').value;
                newData.case_sensitive = document.getElementById('case-sensitive').checked;
                newData.error_message = document.getElementById('error-message').value;
                newData.success_next = document.getElementById('success-next').value;
            } else {
                // Remove password properties if disabled
                delete newData.input_type;
                delete newData.code_title;
                delete newData.code_hint;
                delete newData.correct_code;
                delete newData.case_sensitive;
                delete newData.error_message;
                delete newData.success_next;
            }

            storyData[nodeId] = newData;
            renderVisualization();
            if (cy) {
                const cyNode = cy.getElementById(nodeId);
                if (cyNode.length > 0) {
                    cyNode.style('background-color', nodeColor);
                }
            }
            saveToHistory(
                ACTION_TYPES.NODE_EDIT,
                `–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É–∑–ª–∞ ${nodeId}`,
                oldData,
                newData,
                nodeId
            );
            showStatus(`–£–∑–µ–ª ${nodeId} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!`, "success");
        });

        // ==== –û–°–¢–ê–õ–¨–ù–û–ô –ö–û–î –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô ====
        function initEditor() {
            showLoading();
            setTimeout(() => {
                initIndexedDB()
                    .then(() => console.log("IndexedDB initialized"))
                    .catch(error => {
                        console.error("IndexedDB initialization failed:", error);
                        showStatus("IndexedDB –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –≤ localStorage.", "warning");
                    })
                    .finally(() => {
                        initVisualization();
                        setupResizer();
                        loadEditorState()
                            .then(stateLoaded => {
                                if (!stateLoaded || Object.keys(storyData).length === 0) {
                                    loadTestData();
                                }
                                setupEventListeners();
                                updateStatus();
                                isInitialized = true;
                                hideLoading();
                            })
                            .catch(error => {
                                console.error("Error loading editor state:", error);
                                loadTestData();
                                setupEventListeners();
                                updateStatus();
                                isInitialized = true;
                                hideLoading();
                            });
                    });
            }, 100);
        }
        let nodeTextDebounce = null;
        let choiceInputDebounce = null;
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                const activeElement = document.activeElement;
                const isTextEditing = activeElement && (
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.tagName === 'INPUT' ||
                    activeElement.isContentEditable
                );
                if (isTextEditing && (e.key === 'Delete' || e.key === 'Backspace')) {
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                    e.preventDefault();
                    redo();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    const selectedNodeId = editorState.lastSelectedNode;
                    if (selectedNodeId && cy && cy.$(`#${selectedNodeId}:selected`).length > 0) {
                        if (confirm(`–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —É–∑–µ–ª ${selectedNodeId}?`)) {
                            deleteSelectedNode(selectedNodeId);
                        }
                    }
                }
            });
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (event) {
                    try {
                        const json = JSON.parse(event.target.result);
                        if (!validateJsonStructure(json)) {
                            throw new Error("–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ JSON —Ñ–∞–π–ª–∞.");
                        }
                        loadData(json);
                        e.target.value = '';
                    } catch (error) {
                        showStatus(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: ${error.message}`, "error");
                        console.error("Error loading JSON:", error);
                    }
                };
                reader.onerror = () => showStatus("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞", "error");
                reader.readAsText(file);
            });
            document.getElementById('save-state-btn').addEventListener('click', saveStateToFile);
            document.getElementById('load-state-btn').addEventListener('click', () => document.getElementById('state-file-input').click());
            document.getElementById('state-file-input').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;
                loadStateFromFile(file);
                e.target.value = '';
            });
            // ==== –û–ë–ù–û–í–õ–Å–ù–ù–´–ô –≠–ö–°–ü–û–†–¢ JSON ====
            document.getElementById('export-json').addEventListener('click', () => {
                const exportData = {};
                Object.keys(storyData).forEach(id => {
                    const node = storyData[id];
                    const exportedNode = { text: node.text };
                    exportedNode.choices = node.choices || [];
                    if (node.tag) exportedNode.tag = node.tag;

                    // === –≠–ö–°–ü–û–†–¢ –õ–û–ö–ê–¶–ò–û–ù–ù–´–• –ü–û–õ–ï–ô ===
                    if (node.is_location) {
                        exportedNode.is_location = true;
                        exportedNode.location_name = node.location_name || '';
                        exportedNode.location_icon = node.location_icon || 'üìç';
                        exportedNode.location_category = node.location_category || 'other';
                        exportedNode.category_name = node.category_name || '';
                        exportedNode.location_description = node.location_description || '';
                    }

                    // === –≠–ö–°–ü–û–†–¢ NPC –¢–ï–ì–ê ===
                    if (node.tags && node.tags.length > 0) {
                        exportedNode.tags = node.tags;
                    }

                    exportData[id] = exportedNode;
                });

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                saveAs(blob, 'story-data.json');
                showStatus("JSON —É—Å–ø–µ—à–Ω–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ª–æ–∫–∞—Ü–∏–π!", "success");
                setUnsavedChanges(false);
            });

            document.getElementById('node-list').addEventListener('change', (e) => selectNode(e.target.value));

            document.getElementById('add-choice').addEventListener('click', () => {
                const nodeId = document.getElementById('node-id').textContent;
                if (!storyData[nodeId]) return;
                const oldChoices = JSON.parse(JSON.stringify(storyData[nodeId].choices));
                storyData[nodeId].choices.push({ text: "–ù–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –≤—ã–±–æ—Ä–∞", next: "" });
                saveToHistory(
                    ACTION_TYPES.CHOICE_EDIT,
                    `–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –≤ —É–∑–µ–ª ${nodeId}`,
                    oldChoices,
                    storyData[nodeId].choices,
                    nodeId
                );
                selectNode(nodeId);
            });

            document.getElementById('choices-container').addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-choice')) {
                    const index = parseInt(e.target.dataset.index);
                    const nodeId = document.getElementById('node-id').textContent;
                    if (storyData[nodeId]?.choices && index >= 0 && index < storyData[nodeId].choices.length) {
                        const oldChoices = JSON.parse(JSON.stringify(storyData[nodeId].choices));
                        storyData[nodeId].choices.splice(index, 1);
                        saveToHistory(
                            ACTION_TYPES.CHOICE_EDIT,
                            `–£–¥–∞–ª–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–∞ ${index + 1} –≤ —É–∑–ª–µ ${nodeId}`,
                            oldChoices,
                            storyData[nodeId].choices,
                            nodeId
                        );
                        selectNode(nodeId);
                    }
                }
            });

            document.getElementById('add-new-node').addEventListener('click', () => {
                let newNodeId = 0;
                while (storyData[newNodeId] !== undefined) newNodeId++;
                const newNodeData = {
                    text: `–ù–æ–≤—ã–π —É–∑–µ–ª ${newNodeId}.`,
                    choices: [{ "text": "–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", "next": "" }],
                    color: "#4cc9f0",
                    tag: ""
                };
                const oldData = JSON.parse(JSON.stringify(storyData));
                storyData[newNodeId] = newNodeData;
                populateNodeList();
                selectNode(newNodeId.toString());
                renderVisualization();
                saveToHistory(
                    ACTION_TYPES.NODE_ADD,
                    `–°–æ–∑–¥–∞–Ω–∏–µ —É–∑–ª–∞ ${newNodeId}`,
                    oldData,
                    storyData,
                    newNodeId.toString()
                );
                showStatus(`–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —É–∑–µ–ª ${newNodeId}`, "success");
            });

            document.getElementById('delete-node').addEventListener('click', () => {
                const nodeId = document.getElementById('node-id').textContent;
                if (nodeId && storyData[nodeId]) {
                    if (confirm(`–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —É–∑–µ–ª ${nodeId}?`)) {
                        deleteSelectedNode(nodeId);
                    }
                }
            });

            document.getElementById('reset-layout').addEventListener('click', () => {
                if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤—Å–µ—Ö —É–∑–ª–æ–≤?")) {
                    const oldPositions = JSON.parse(JSON.stringify(editorState.nodePositions || {}));
                    editorState.nodePositions = {};
                    if (cy && cy.elements().length > 0) {
                        cy.layout({ name: 'cose', animate: true, animationDuration: 1000 }).run();
                        cy.animate({ fit: { eles: cy.elements(), padding: 50 }, duration: 1000 });
                    }
                    saveToHistory(
                        ACTION_TYPES.LAYOUT_RESET,
                        "–°–±—Ä–æ—Å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è —É–∑–ª–æ–≤",
                        oldPositions,
                        {}
                    );
                    saveEditorState();
                    showStatus("–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —É–∑–ª–æ–≤ —Å–±—Ä–æ—à–µ–Ω–æ", "success");
                }
            });

            document.getElementById('search-btn').addEventListener('click', () => {
                const searchTerm = document.getElementById('search-node').value.trim();
                if (!searchTerm) {
                    showStatus("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞", "error");
                    return;
                }
                if (storyData[searchTerm]) {
                    selectNode(searchTerm);
                    return;
                }
                for (const nodeId in storyData) {
                    if (storyData[nodeId].text.toLowerCase().includes(searchTerm.toLowerCase())) {
                        selectNode(nodeId);
                        showStatus(`–ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ —É–∑–ª–µ ${nodeId}`, "success");
                        return;
                    }
                }
                showStatus('–£–∑–µ–ª —Å —Ç–∞–∫–∏–º ID –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω', "error");
            });

            document.getElementById('auto-save-checkbox').addEventListener('change', (e) => {
                editorState.autoSave = e.target.checked;
                if (editorState.autoSave) {
                    saveEditorState();
                    showStatus("–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ", "success");
                } else {
                    showStatus("–ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ. –ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—Ä—É—á–Ω—É—é!", "error");
                }
            });

            document.getElementById('node-tag').addEventListener('blur', function () {
                const nodeId = document.getElementById('node-id').textContent;
                if (nodeId && storyData[nodeId]) {
                    const oldData = JSON.parse(JSON.stringify(storyData[nodeId]));
                    const newTag = this.value.trim();
                    storyData[nodeId].tag = newTag;
                    saveToHistory(
                        ACTION_TYPES.NODE_EDIT,
                        `–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–≥–∞ —É–∑–ª–∞ ${nodeId}`,
                        oldData,
                        storyData[nodeId],
                        nodeId
                    );
                    setUnsavedChanges(true);
                    renderVisualization();
                }
            });

            setInterval(() => {
                if (editorState.autoSave && hasUnsavedChanges) {
                    saveEditorState();
                }
            }, 30000);

            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges) {
                    e.preventDefault();
                    e.returnValue = '–£ –≤–∞—Å –µ—Å—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è. –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∫–∏–Ω—É—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É?';
                    return e.returnValue;
                }
            });

            document.getElementById('node-text').addEventListener('input', () => {
                setUnsavedChanges(true);
                const nodeId = document.getElementById('node-id').textContent;
                if (!nodeId || !storyData[nodeId]) return;
                clearTimeout(nodeTextDebounce);
                nodeTextDebounce = setTimeout(() => {
                    const currentText = document.getElementById('node-text').value;
                    const oldText = storyData[nodeId].text;
                    if (currentText !== oldText) {
                        const oldData = JSON.parse(JSON.stringify(storyData[nodeId]));
                        storyData[nodeId].text = currentText;
                        saveToHistory(
                            ACTION_TYPES.NODE_EDIT,
                            `–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —É–∑–ª–∞ ${nodeId}`,
                            oldData,
                            storyData[nodeId],
                            nodeId
                        );
                    }
                }, 1000);
            });

            document.getElementById('node-color').addEventListener('input', function () {
                document.getElementById('color-preview').style.backgroundColor = this.value;
                setUnsavedChanges(true);
            });

            document.getElementById('choices-container').addEventListener('input', (e) => {
                if (e.target.classList.contains('choice-text') || e.target.classList.contains('choice-next')) {
                    setUnsavedChanges(true);
                    const nodeId = document.getElementById('node-id').textContent;
                    if (!nodeId || !storyData[nodeId]) return;
                    clearTimeout(choiceInputDebounce);
                    choiceInputDebounce = setTimeout(() => {
                        const oldChoices = JSON.parse(JSON.stringify(storyData[nodeId].choices));
                        const newChoices = [];
                        document.querySelectorAll('.choice-item').forEach(item => {
                            const textEl = item.querySelector('.choice-text');
                            const nextEl = item.querySelector('.choice-next');
                            newChoices.push({ text: textEl.value, next: nextEl.value.trim() });
                        });
                        if (JSON.stringify(oldChoices) !== JSON.stringify(newChoices)) {
                            storyData[nodeId].choices = newChoices;
                            saveToHistory(
                                ACTION_TYPES.CHOICE_EDIT,
                                `–ò–∑–º–µ–Ω–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —É–∑–ª–∞ ${nodeId}`,
                                oldChoices,
                                newChoices,
                                nodeId
                            );
                        }
                    }, 1000);
                }
            });

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–∞—Ä–æ–ª—è
            document.getElementById('node-password-checkbox').addEventListener('change', function () {
                const passwordFields = document.getElementById('password-fields');
                const nodeText = document.getElementById('node-text');
                if (this.checked) {
                    passwordFields.style.display = 'block';
                    nodeText.style.display = 'none';
                } else {
                    passwordFields.style.display = 'none';
                    nodeText.style.display = 'block';
                }
                setUnsavedChanges(true);
            });

            // === –ù–û–í–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –ß–ï–ö–ë–û–ö–°–ê –õ–û–ö–ê–¶–ò–ò ===
            document.getElementById('node-is-location-checkbox').addEventListener('change', function () {
                const locationFields = document.getElementById('location-fields');
                locationFields.style.display = this.checked ? 'block' : 'none';
                setUnsavedChanges(true);
            });

            document.getElementById('node-is-npc-checkbox').addEventListener('change', function () {
                setUnsavedChanges(true);
            });
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–∞ –∏ –∏–∫–æ–Ω–æ–∫
        document.addEventListener('DOMContentLoaded', () => {
            const hexInput = document.getElementById('node-color-hex');
            const colorPicker = document.getElementById('node-color');
            const preview = document.getElementById('color-preview');
            hexInput?.addEventListener('input', () => {
                let value = hexInput.value.trim();
                if (value.startsWith('#') && value.length === 7) {
                    try {
                        colorPicker.value = value;
                        preview.style.backgroundColor = value;
                        setUnsavedChanges(true);
                    } catch (e) {
                        // ignore
                    }
                }
            });
            colorPicker?.addEventListener('input', () => {
                const value = colorPicker.value;
                hexInput.value = value;
                preview.style.backgroundColor = value;
                setUnsavedChanges(true);
            });

            // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ö–û–ù–û–ö –õ–û–ö–ê–¶–ò–ô ===
            initLocationIcons();
        });

        document.addEventListener('DOMContentLoaded', initEditor);
    </script>
</body>

</html>
